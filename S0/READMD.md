# Introduce Shell

> ~~사실 원래는 안하려고 했었음~~

## What is Shell

우리가 사용하는 익숙한 컴퓨터는 모두 GUI(Graphic User Interface)를 제공한다. 마우스가 존재하고, 마우스 포인터를 통해 화면을 클릭이라는 개념으로 파일과 폴더를 이용 가능한 체제를 GUI라고 부른다.

그에 반해 고대의 컴퓨터들은 CLI(Command LIne Interface)만을 제공했는데, 이는 컴퓨터 전체가 검은 화면에 글씨와 껌뻑거리는 커서 뿐이었다는 얘기다.

현재도 CLI는 간단한 작업을 위해 사용되기도 하며, 그렇기에 GUI 컴퓨터라도 CLI를 내장해주고 있다. 지금 한번 셸 창을 열어보자.

> Win: Windows Power Shell을 사용, CMD는 사용하지 않을 건데, Linux와 다른 부분이 너무 많기 때문이다.
> Linux: Linux Shell을 사용
>

셸 창에는 기본적으로 마우스는 통하지 않고, 오직 키보드로만 모든 조작을 가한다고 볼 수 있다. 마우스를 쓸 수 있는 현대식 셸이더라도 연습하는동안은 한번 마우스 없이 조작을 해보자.

## 실습

셸창에는 기본적으로 현재 내가 작업하고 있는 공간의 위치를 알려주는 글씨가 커서 앞에 먼저 보여진다. 가령 예시로 내 Windows PS에서는 `PS C:\Users\LSW>`가 현재 커서 앞에 먼저 출력되는 것을 볼 수 있는데, 저기 쓰인 경로가 바로 내 현재 위치라고 볼 수 있다. `LSW`는 윈도우 상에서 내 유저 이름이고, 사용자가 정한 이름에 따라 다르게 표시될 것이다. 참고로 흔히 말하는 바탕화면은 이 아래의 `C:\Users\[YOUR_NAME]\Desktop`에 있다. 현재 우리는 바탕화면 위의 유저 공간에 위치해있는 것이다.

리눅스도 이와 유사하지만 조금 다른 정보가 출력되는데, `[YOUR_NAME]@[DESKTOP_NAME]:[PATH]$`형태로 보통 출력된다. 여기서 `[YOUR_NAME]`은 내 `LSW`와 같은 유저 이름, [DESKTOP_NAME]은 컴퓨터 이름, `[PATH]`는 내 현재 위치이다. 특기할 점은 리눅스는 현재 경로로 특이하게도 `~`를 사용하는 경우가 있는데, 이 경우 `~`은 내 유저 공간, 즉 `/home/[YOUR_NAME]`을 의미한다. 실제로 저 `~` 공간에서 상위 폴더로 가보면, 현재 위치가 `/home`으로 바뀌는 것을 볼 수 있다. 리눅스도 GUI 버전이라면, 바탕화면은 이 아래에 있다.

내가 현재 위치한 폴더를 이하 "작업공간"이라고 부른다.

### ls (list)

셸창에 `ls`라고 입력해보면, 여러 목록이 출력될 것이다. 이것은 내가 현재 위치한 작업공간에 들어있는 하위 폴더와 파일들의 이름을 출력한 것이다. 이를 통해 우리고 폴더를 마우스로 더블클릭하면 내용물이 보이던 형태에서, 폴더 안에 들어있는 것을 확인하고 싶다면 수동으로 `ls`를 입력해야 확인할 수 있음을 알게 되었다. 이처럼 CLI의 한계상 조금 다른 매커니즘으로 같은 행위를 구현하였다.

`ls`에는 옵션이 있는데 `ls -l`을 사용하면 좀 더 자세히 정보를 출력하게 되고, `ls -a`를 사용하면 숨김 폴더까지 찾아내게 된다. ~~신기하게도 옛날에 `ls -a`는 널리 알려진 적이 있었는데, 친구 집 컴퓨터에서 숨김 폴더 찾는 법으로 소개된 적이 있다~~

### cd (current directory)

`cd`는 작업공간을 이동할 때 쓰인다. 아까 현재 작업 공간이 유저 공간이었다면, `cd [MOVE_PATH]`를 통해 `[MOVE_PATH]`로 이동할 수 있다. 예를들어 `ls`의 결과로 바탕화면이 있었다면, `cd Desktop`을 하면 바탕화면으로 가는 것을 볼 수 있을 것이다.

기본적으로 `cd`는 상대 경로법을 사용한다. 즉 현재 위치를 기준으로 해당 위치로 이동하는데, 절대 경로를 사용하려면 저 `[MOVE_PATH]`가 윈도우에서는 드라이브 문자(`C:\`, `D:\` 등)로 시작하면 되고, 리눅스에서는 `/`, `~`로 시작하면 절대 경로를 사용한다.

또한 현재 폴더는 `.`으로, 부모 폴더는 `..`으로 표시하는 관례에 따라, 부모 폴더로 이동하고 싶다면 `cd ..`을 이용할 수 있다. 위의 `ls`도 사실 `ls [PATH]`로 사용할 수 있으며, 기본적으로 `[PATH]`를 제공하지 않으면 `.`으로 이해하는 방식이다.

### mkdir (make directory)

`mkdir`은 이름처럼 폴더을 만드는 기본적인 명령어로, 간단하게 `mkdir [PATH]`로 사용한다.

### touch **Only Linux**

`touch`는 리눅스에서만 사용 가능한 명령어로, 빈 파일을 생성하는 명령어다. `touch [FILE_NAME]`으로 사용한다.

### echo

`echo`는 내 명령을 그대로 다시 뱉는 명령어이다. 예를들어 `echo "Hello, world!"`라고 하면, `"Hello, world!"`만 다시 출력되고 아무 변화도 없는 것을 볼 수 있을 것이다. 보통 단독으로 사용하지는 않고 가장 흔한 조합이 `>`과의 조합인데, `[A] > [B]`는 `[A]` 명령의 결과로 나온 내용을 `[B]` 파일에 쓰라는 의미로, 간단하게 `echo [YOUR_MSG] > [TARGET_FILE]`을 통해 `[YOUR_MSG]`를 `[TARGET_FILE]`에 쓸 수 있다. 이 쓰기는 기본적으로 덮어쓰기이므로 이어지지 않고, `>` 대신 `>>`을 통해 이어쓰기가 가능하다.

### cat (catch)

`cat`은 파일의 내용을 확인하는 커맨드로, `cat [FILE_NAME]`을 하면 파일에 담긴 내용이 간단하게 출력된다. 빠르게 파일의 내용을 확인하고 싶을 때 쓰인다.

### mv/cp (move/copy)

`mv`와 `cp`는 이동 및 복사로, `[mv|cp] [SOURCE] [TARGET]`으로 쓰인다. 예를 들어 `mv hello.txt ..`이라면, 작업공간의 `hello.txt`를 부모 폴더로 이동시킬 수 있고, 같은 매커니즘으로 `cp hello.txt ..`는 작업공간의 `hello.txt`를 부모 폴더로 복사한다. 같은 사용법을 가져 함께 설명하였다.

차이점은 `cp`의 경우 대상이 폴더고, 안에 내용물이 있다면 `cp [SOURCE] [TARGET]` 대신 `-r`을 넣어 `cp -r [SOURCE] [TARGET]`을 써야한다. `-r`은 Recursive의 약자로, 재귀적으로 하위 내용물에 모두 같은 명령어를 적용하라는 뜻이다. 즉, `cp`는 기본적으로는 단일 대상을 타겟으로 한다는 것을 유추해 볼 수 있겠다.

### rm (remove)

`rm`은 삭제 명령으로 `rm [PATH]`로 사용한다. 역시 단일 대상을 타겟으로 하며, 모든 하위 내용물을 싹다 지우려면 `rm -r`을 사용한다. 간혹 쓰기 보호된 파일은 지우기 전에 정말 지울거냐고 묻는 경우가 있는데, 이런 파일들을 질문 없이 한방에 날리려면 `rm -rf`를 사용할 수 있다. `-f`가 추가됨으로서 해당 기능이 활성화 된다.

### sudo (super user do) **Only Linux**

모든 명령어 앞에 `sudo`를 붙여 권한이 부족해서 발생하는 오류를 해결할 수 있다. 내가 해당 시스템의 설치자이고, 내 유저가 첫 계정이라면 기본적으로 그 계정은 보통 `sudo`를 사용할 수 있다.

유저의 비밀번호는 이때 쓰이며, `sudo` 명령어 다음 비밀번호를 입력하면 해당 명령의 관리자 권한으로 실행되는 것이다. 윈도우에서는 관리자 권한으로 실행된 PS이 이 역할을 대신한다.

보통 무언가 다운로드 받거나, 시스템 영역의 무언가를 건드릴 때 필요하며, 대표적으로 `sudo apt install [PACKAGE_NAME]`을 통해 필요한 소프트웨어를 설치할 수 있다.

## 미션

**절대 입력해서 알아보려고 하지는 말자.**

`sudo rm -rf /`에 대해서 **인터넷에 검색해서** 조사해보자.

---

### References
1. Test alone

<p align=center><a href="../README.md">Go to main menu</a></p>